/*
    Qore Programming Language process Module

    Copyright (C) 2003 - 2019 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

/* -*- mode: c++; indent-tabs-mode: nil -*- */

#include <qore/Qore.h>

#include "processpriv.h"

#include <cstdlib>

#if defined(__linux__) || (defined(__APPLE__) && defined(__MACH__))
#define HAVE_PROCESS_GETMEMORYINFO 1
#define HAVE_PROCESS_CHECKPID 1
#define HAVE_PROCESS_TERMINATE 1
#define HAVE_PROCESS_WAITFORTERMINATION 1
#else
#define HAVE_PROCESS_GETMEMORYINFO 0
#define HAVE_PROCESS_CHECKPID 0
#define HAVE_PROCESS_TERMINATE 0
#define HAVE_PROCESS_WAITFORTERMINATION 0
#endif

DLLLOCAL extern const TypedHashDecl* hashdeclMemorySummaryInfo;

/** @defgroup process_constants Process Constants
    Constants related to process module functionality
 */
//@{
//! defines if the @ref Qore::Process::Process::getMemorySummaryInfo() "Process::getMemorySummaryInfo()" methods are available on the current platform
const HAVE_PROCESS_GETMEMORYINFO = bool(HAVE_PROCESS_GETMEMORYINFO);

//! defines if the @ref Qore::Process::Process::checkPid() "Process::checkPid()" method is available on the current platform
const HAVE_PROCESS_CHECKPID = bool(HAVE_PROCESS_CHECKPID);

//! defines if the static @ref Qore::Process::Process::terminate() "Process::terminate()" method is available on the current platform
const HAVE_PROCESS_TERMINATE = bool(HAVE_PROCESS_TERMINATE);

//! defines if the static @ref Qore::Process::Process::waitForTermination() "Process::waitForTermination()" method is available on the current platform
const HAVE_PROCESS_WAITFORTERMINATION = bool(HAVE_PROCESS_WAITFORTERMINATION);
//@}

//! A hash of summary memory information as provided by @ref Qore::Process::Process::getMemorySummaryInfo() "Process::getMemorySummaryInfo()"
/**
*/
hashdecl Qore::Process::MemorySummaryInfo {
    //! the virtual size of the process in bytes including all shared/dynamic libraries, code, and data
    int vsz;
    //! the resident size of the process in bytes (RAM in use)
    int rss;
    //! the private memory size of the process; meaning heap and stack size, without any code or shared/dynamic libraries included; this gives a measure of how much memory the process itself is using
    /** On Linux, this reports the sum of referenced memory in private, writable, non-mmap()ed virtual memory segments
     */
    int priv;
}

//! System process wrapper.
/** A process is an independently executable entity, which is different
    from a thread, in that it has it's own resources. Those include
    memory and hardware resources.

    Every process is identified by a unique number, called the process
    identification digit, pid.

    A process will return an integer value indicating whether it was
    successful. On posix there are more codes associated with that,
    but not so on windows. Therefore there is not such encoding currently
    in the library. However an exit code of zero means the process was
    successful, while one different than zero indicates an error.

    Processes can also be forced to exit. There are two ways to do this,
    signal the process to so and wait, and just terminate the
    process without conditions.

    Usually the first approach is to signal an exit request,
    but windows - unlike posix - does not provide a consistent way
    to do this. Hence this is not part of the library and only
    the hard terminate is.

    The environment is a map of variables local to every process. The
    most significant one for this library is the PATH variable,
    which containes a list of paths, that ought to be searched for
    executables. A shell will do this automatically, while this
    library provides a function for that.

    The child process will be destroyed immediatelly when an instance of
    Process class is destroyed, except if @ref detach() is called.

    The simplest usage of Process is:

    @code
%new-style
%requires process

Process p("ls");
p.wait();
    @endcode

    @section process_options Process Options

    The \c opts hash can hold following keys. All keys are optional.

    - \c env : replace current process's ENV with a hash of env variables.
               Use @code ENV + ( "FOO" : "bar") @endcode is you want to merge parent's ENV to child.
    - \c cwd : a string with initial "current working directory",
               a dir which child should take as its initial work dir
    - \c path : a list of strings. It's a custom search path to find \c command
                in the Process constructors. If it's not given, parent's ENV PATH is used.
                This value is not passed to child's ENV at all.
    - \c on_success : a code/call closure with prototype <tt>sub (hash e)</tt>.
                      This handler is invoked if launching the process has succeeded.
    - \c on_setup : a code/call closure with prototype <tt>sub (hash e)</tt>.
                    This handler is invoked before the process in launched, to setup parameters
    - \c on_error : a code/call closure with prototype <tt>sub (hash e)</tt>.
                    This handler is invoked if an error during launch occured.
    - \c on_fork_error : a code/call closure with prototype <tt>sub (hash e)</tt>.
                         This handler is invoked if the fork failed.
                         Posix only.
    - \c on_exec_setup : a code/call closure with prototype <tt>sub (hash e)</tt>.
                         This handler is invoked if the fork succeeded.
                         Posix only.
    - \c on_exec_error : a code/call closure with prototype <tt>sub (hash e)</tt>.
                         This handler is invoked if the exec call errored.
                         Posix only.

    Option example:

    @code
%new-style
%requires process

sub executor_func(hash e) {
    printf("on_setup: %n\n", e);
}

hash opts = (
    "env" : ( "FOO" : "bar"),
    "cwd" : "/tmp",
    "on_success" : sub (hash e) { # a closure is used
        printf("on_success: %n\n", e);
    },
    "on_setup" : \executor_func(), # a call ref
);

Process p("true", opts);
p.wait();
int ret = p.exitCode();
    @endcode

output of the script will be:

    @code
on_setup: hash: (name : "on_setup", exe : "/usr/bin/true", pid : -1, exit : 127, error_code : 0, error_message : "Success", error_category : "system")
on_success: hash: (name : "on_success", exe : "/usr/bin/true", pid : 23014, exit : 127, error_code : 0, error_message : "Success", error_category : "system")    @endcode

 */
qclass Process [dom=EXTERNAL_PROCESS; arg=ProcessPriv* priv; ns=Qore::Process];

//! Construct the child from a PID.
/**
    @param id the PID of the process.

    @note The only functionality available when this constructor is used is id(); all other calls will fail
 */
Process::constructor(int pid) {
    self->setPrivate(CID_PROCESS, new ProcessPriv(pid, xsink));
}

//! Construct a child from given arguments and launch it.
/**
    @param command a string with program to be run; can be either an absolute path or a simple command to be found in the search path

    @throw PROCESS-CONSTRUCTOR-ERROR in case of error. Exception \c desc contains the additional information
    @throw PROCESS-SEARCH-PATH-ERROR in case the \c command is not found in given PATH
 */
Process::constructor(string command) {
    self->setPrivate(CID_PROCESS, new ProcessPriv(command->getBuffer(), 0, 0, xsink));
}

//! Construct a child from given arguments and launch it.
/**
    @param command a string with program to be run; can be either an absolute path or a simple command to be found in the search path
    @param opts a hash with additional options for the child process @ref process_options

    @throw PROCESS-CONSTRUCTOR-ERROR in case of error. Exception \c desc contains the additional information
    @throw PROCESS-OPTIONS-ERROR in case invalid option is passed
    @throw PROCESS-SEARCH-PATH-ERROR in case the \c command is not found in given PATH
 */
Process::constructor(string command, hash opts) {
    self->setPrivate(CID_PROCESS, new ProcessPriv(command->getBuffer(), 0, opts, xsink));
}

//! Construct a child from given arguments and launch it.
/**
    @param command a string with program to be run; can be either an absolute path or a simple command to be found in the search path
    @param arguments a list with additiona \c command arguments

    @throw PROCESS-CONSTRUCTOR-ERROR in case of error. Exception \c desc contains the additional information
    @throw PROCESS-SEARCH-PATH-ERROR in case the \c command is not found in given PATH
 */
Process::constructor(string command, softlist arguments) {
    self->setPrivate(CID_PROCESS, new ProcessPriv(command->getBuffer(), arguments, 0, xsink));
}

//! Construct a child from given arguments and launch it.
/**
    @param command a string with program to be run; can be either an absolute path or a simple command to be found in the search path
    @param arguments a list with additiona \c command arguments
    @param opts a hash with additional options for the child process. See @ref process_options

    @throw PROCESS-CONSTRUCTOR-ERROR in case of error. Exception \c desc contains the additional information
    @throw PROCESS-OPTIONS-ERROR in case invalid option is passed
    @throw PROCESS-SEARCH-PATH-ERROR in case the \c command is not found in given PATH
 */
Process::constructor(string command, softlist arguments, hash opts) {
    self->setPrivate(CID_PROCESS, new ProcessPriv(command->getBuffer(), arguments, opts, xsink));
}

//! Copy method - instance of this class cannot be copied.
/**
    @throw PROCESS-COPY-ERROR Copying of Process objects is not supported
 */
Process::copy() {
   xsink->raiseException("PROCESS-COPY-ERROR", "copying Proces objects is currently not supported");
}

//! Get the child process's exit code.
/** The return value is without any meaning if the child wasn't waited for or if it was terminated.

    @return child process's exit code

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
int Process::exitCode() {
    return priv->exitCode(xsink);
}

//! Get the Process Identifier.
/**
    @return child process's PID

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
int Process::id() {
    return priv->id(xsink);
}

//! Check if this handle holds a child process.
/** That does not mean, that the process is still running. It only means, that the handle does or did exist.

    @return \c True in case of valid child handle

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
bool Process::valid() {
    return priv->valid(xsink);
}

//! Check if the child process is running.
/**
    @return \c True if the child is running

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized

    @see @ref Process::checkPid()
*/
bool Process::running() {
    return priv->running(xsink);
}

//! Wait for the child process to exit.
/**
    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized

    @return always returns \c True to keep compatibility with wait(timeout) version

    Example:
    @code
Process p("sleep", 3);
p.wait(); # a blocking/wait call
printf("Sleep finished with code: %d\n", p.exitCode());
    @endcode
 */
bool Process::wait() {
    return priv->wait(xsink);
}

//! Wait for the child process to exit.
/**
    @param t a timeout to wait

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized

    @return \c True if child exited while waiting, \c False in case of timeout

    Example:
    @code
Process p("sleep", 3);
while (!p.wait(1)) {
    printf("I'm doing something here...\n");
}
printf("Sleep finished with code: %d\n", p.exitCode());
    @endcode
 */
bool Process::wait(timeout t) {
    return priv->wait(t, xsink);
}

//! Detach the child, i.e. let it run after this handle dies.
/**
    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
nothing Process::detach() {
    priv->detach(xsink);
}

//! Terminate the child process.
/** This function will cause the child process to unconditionally
    and immediately exit. It is implemented with SIGKILL on posix
    and TerminateProcess on windows.

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
nothing Process::terminate() {
    priv->terminate(xsink);
}

//! Write into child's \c stdin
/** @param s a string data to be writen

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
nothing Process::write(string s) {
    priv->write(s->c_str(), s->size(), xsink);
}

//! Write into child's \c stdin
/** @param b a binary data to be writen

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
nothing Process::write(binary b) {
    priv->write(static_cast<const char*>(b->getPtr()), b->size(), xsink);
}

//! Write into child's \c stdin
/** @param i an integer to be writen

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
nothing Process::write(int i) {
    QoreStringNodeValueHelper s(i);
    priv->write(s->c_str(), s->size(), xsink);
}

//! Write into child's \c stdin
/** @param f a float to be writen

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
nothing Process::write(float f) {
    QoreStringNodeValueHelper s(f);
    priv->write(s->c_str(), s->size(), xsink);
}

//! Write into child's \c stdin
/** @param n a number to be writen

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
 */
nothing Process::write(number n) {
    QoreStringNodeValueHelper s(n);
    priv->write(s->c_str(), s->size(), xsink);
}

//! Read from child process's standard output.
/** Reads data from child process's standard output. If no timeout is given, or
    timeout is 0 or negative, the method reads all data that is currently available
    up to the count passed in \c bytes parameter and then returns immediately.
    If no data is available, it will return NOTHING.

    If positive timeout value is passed, then the method reads all data that is
    currently available up to the count passed in \c bytes parameter and then
    returns immediately. If no data is available, it will sleep until timeout
    and then try to read. If there is still no data, it will return.

    This method does not guarantee that any data will be read or that \c bytes
    count of bytes will be read.

    @param bytes a maximum count of bytes to read
    @param timeout timeout in milliseconds; if 0 or negative, the method will return immediately if there is no data available

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
    @throw PROCESS-READ-ERROR in case of read error

    @returns string with data or NOTHING if no data is available
 */
*string Process::readStdout(int bytes, int timeout = 0) {
    if (bytes < 0)
        return QoreValue();

    if (timeout > 0)
        return priv->readStdoutTimeout(static_cast<size_t>(bytes), timeout, xsink);
    return priv->readStdout(static_cast<size_t>(bytes), xsink);
}

//! Read from child process's standard error output.
/** Reads data from child process's standard error output. If no timeout is given,
    or timeout is 0 or negative, the method reads all data that is currently
    available up to the count passed in \c bytes parameter and then returns immediately.
    If no data is available, it will return NOTHING.

    If positive timeout value is passed, then the method reads all data that is
    currently available up to the count passed in \c bytes parameter and then
    returns immediately. If no data is available, it will sleep until timeout
    and then try to read. If there is still no data, it will return.

    This method does not guarantee that any data will be read or that \c bytes
    count of bytes will be read.

    @param bytes a maximum count of bytes to read
    @param timeout timeout in milliseconds; if 0 or negative, the method will return immediately if there is no data available

    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized
    @throw PROCESS-READ-ERROR in case of read error

    @returns string with data or NOTHING if no data is available
 */
*string Process::readStderr(int bytes, int timeout = 0) {
    if (bytes < 0)
        return QoreValue();

    if (timeout > 0)
        return priv->readStderrTimeout(static_cast<size_t>(bytes), timeout, xsink);
    return priv->readStderr(static_cast<size_t>(bytes), xsink);
}

//! Returns process information for the process managed by the current object
/**
    @return a @ref MemorySummaryInfo hash of memory info

    @throw PROCESS-GETMEMORYINFO-ERROR an error occurred querying the process's memory usage (PID does not exist or no permission to read the process's virtual memory tables)
    @throw PROCESS-GETMEMORYINFO-UNSUPPORTED-ERROR this exception is thrown if there is no implementation for this method on the current platform
    @throw PROCESS-CHECK-ERROR in case child handle was not properly initialized

    @note
    - this method has been implemented for Linux and MacOS only; on all other platforms a \c PROCESS-GETMEMORYINFO-UNSUPPORTED-ERROR exception is thrown
    - on MacOS the memory of another process cannot be read unless the calling process has root privileges or the process has the \c "com.apple.system-task-ports" entitlement

    @see HAVE_PROCESS_GETMEMORYINFO
*/
hash<MemorySummaryInfo> Process::getMemorySummaryInfo() {
    int pid = priv->id(xsink);
    if (*xsink)
        return QoreValue();
    return ProcessPriv::getMemorySummaryInfo(pid, xsink);
}

//! Search for full path of command in current process's PATH
/**
    @param command command name

    @return string with full path of the \c command

    @throw PROCESS-SEARCH-PATH-ERROR in case the \c command is not found in given PATH
 */
static *string Process::searchPath(string command) {
    return new QoreStringNode(ProcessPriv::optsPath(command->getBuffer(), 0, xsink).string());
}

//! Search for full path of command in current process's PATH
/**
    @param command command name
    @param opts a hash with process options. @ref process_options - \c path is important here

    @return string with full path of the \c command

    @throw PROCESS-SEARCH-PATH-ERROR in case the \c command is not found in given PATH
 */
static *string Process::searchPath(string command, hash opts) {
    return new QoreStringNode(ProcessPriv::optsPath(command->getBuffer(), opts, xsink).string());
}

//! Returns process information for the current process
/**
    @return a @ref MemorySummaryInfo hash of memory info

    @throw PROCESS-GETMEMORYINFO-ERROR an error occurred querying the process's memory usage (PID does not exist or no permission to read the process's virtual memory tables)
    @throw PROCESS-GETMEMORYINFO-UNSUPPORTED-ERROR this exception is thrown if there is no implementation for this method on the current platform

    @note
    - this method has been implemented for Linux and MacOS only; on all other platforms a \c PROCESS-GETMEMORYINFO-UNSUPPORTED-ERROR exception is thrown
    - on MacOS the memory of another process cannot be read unless the calling process has root privileges or the process has the \c "com.apple.system-task-ports" entitlement

    @see HAVE_PROCESS_GETMEMORYINFO
*/
static hash<MemorySummaryInfo> Process::getMemorySummaryInfo() {
    return ProcessPriv::getMemorySummaryInfo(getpid(), xsink);
}

//! Returns process information for the given PID
/**
    @param pid the PID of the process

    @return a @ref MemorySummaryInfo hash of memory info

    @throw PROCESS-GETMEMORYINFO-ERROR an error occurred querying the process's memory usage (PID does not exist or no permission to read the process's virtual memory tables)
    @throw PROCESS-GETMEMORYINFO-UNSUPPORTED-ERROR this exception is thrown if there is no implementation for this method on the current platform

    @note
    - this method has been implemented for Linux and MacOS only; on all other platforms a \c PROCESS-GETMEMORYINFO-UNSUPPORTED-ERROR exception is thrown
    - on MacOS the memory of another process cannot be read unless the calling process has root privileges or the process has the \c "com.apple.system-task-ports" entitlement

    @see HAVE_PROCESS_GETMEMORYINFO
*/
static hash<MemorySummaryInfo> Process::getMemorySummaryInfo(int pid) {
    return ProcessPriv::getMemorySummaryInfo(pid, xsink);
}

//! Returns @ref Qore::True "True" if the process is running, @ref Qore::False "False" if not
/**
    @param pid the PID of the process

    @return @ref Qore::True "True" if the process is running, @ref Qore::False "False" if not

    @throw PROCESS-CHECKPID-UNSUPPORTED-ERROR this exception is thrown if there is no implementation for this method on the current platform

    @note this method has been implemented for Unix and Unix-like systems only; on all other platforms a \c PROCESS-CHECKPID-UNSUPPORTED-ERROR exception is thrown

    @see
    - @ref HAVE_PROCESS_CHECKPID
    - @ref Process::running()
*/
static bool Process::checkPid(int pid) {
    return ProcessPriv::checkPid(pid, xsink);
}

//! terminate a process unconditionally given its PID
/**
    @param pid PID of the process to terminate

    @throw PROCESS-TERMINATE-ERROR insufficient permissions to terminate process
    @throw PROCESS-INVALID-PID invalid PID
    @throw PROCESS-TERMINATE-UNSUPPORTED-ERROR this exception is thrown if there is no implementation for this method on the current platform

    @note this method will also clean up any child processes if necessary (i.e. on Unix-like platforms) in case the process killed is a child of the current process

    @see
    - @ref HAVE_PROCESS_TERMINATE
    - @ref Process::terminate()
*/
static nothing Process::terminate(int pid) {
    ProcessPriv::terminate(pid, xsink);
}

//! wait until a given PID terminates
/**
    @param pid PID of the process to wait for

    @throw PROCESS-WAITFORTERMINATION-UNSUPPORTED-ERROR this exception is thrown if there is no implementation for this method on the current platform

    @see
    - @ref HAVE_PROCESS_WAITFORTERMINATION
    - @ref Process::terminate()
*/
static nothing Process::waitForTermination(int pid) {
    ProcessPriv::waitForTermination(pid, xsink);
}

//! returns a list of three CPU load average values, giving the load average in the last 1, 5, and 15 minutes
/** @par Example:
    @code{.py}
list<float> l = Process::getLoadAvg();
printf("load in the last minute was: %y\n", l[0]);
    @endcode

    @return a list of three CPU load average values, giving the load average in the last 1, 5, and 15 minutes

    @throw PROCESS-GETLOADAVG-ERROR an error occurred calling getloadavg()
*/
static list<float> Process::getLoadAvg() [flags=RET_VALUE_ONLY] {
    double loadavg[3];

    int rc = getloadavg(loadavg, 3);
    if (rc != 3) {
        xsink->raiseException("PROCESS-GETLOADAVG-ERROR", "an error occurred calling getloadavg()");
        return QoreValue();
    }

    ReferenceHolder<QoreListNode> rv(new QoreListNode(floatTypeInfo), xsink);
    for (unsigned i = 0; i < 3; ++i) {
        rv->push(loadavg[i], xsink);
        assert(!*xsink);
    }
    return rv.release();
}