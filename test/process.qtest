#!/usr/bin/env qore

%new-style

%requires process
%requires QUnit
%requires Util

%exec-class Main

# to be used in static methods and separate functions
our *softbool VERBOSE;
our Main MAIN;

public class Main inherits QUnit::Test {
    private {
        # prefix to find other test scripts
        string m_prefix;

        hash m_test_paths = (
            "DEFAULT" : (
                "testTrue" : "test_true.q",
                "testSleep" : "test_sleep.q",
            ),
            "LINUX" : (
                "searchPathTest_in" : "ls",
                "searchPathTest_out" : "^(/usr)?/bin/ls$",
                "simpleTest_exe" : "ls",
                "simpleTest_arg" : ("-l" , "-s",),
                "executorsTest_success" : "Success",
            ),
            "WINDOWS" : (
                "searchPathTest_in" : "timeout",
            ),
            "DARWIN" : (
                "searchPathTest_in" : "ls",
                "searchPathTest_out" : dirname(ENV.SHELL) + "/ls",
                "simpleTest_exe" : "ls",
                "simpleTest_arg" : ("-l" , "-s",),
                "executorsTest_success" : "Undefined error: 0",
            ),
        );
    }

    constructor() : Test("Process", "1.0") {
        VERBOSE = m_options.verbose;
        MAIN = self;

        # expand relative path to a fully qualified one
        Dir d();
        d.chdir(get_script_dir());
        m_prefix = d.path() + DirSep;

        addTestCase("searchPath test", \searchPathTest());
        addTestCase("absolute test", \absoluteTest());
        addTestCase("Constructor test", \constructorTest());
        addTestCase("Simple test", \simpleTest());
        addTestCase("Single test negative", \simpleTestNegative());
        addTestCase("IO test", \ioTest());
        addTestCase("Executor events test: closure", \executorsTest());
        addTestCase("Executor events test: refs", \executorsRefsTest());
        addTestCase("Executor negative test", \executorsNegativeTest());
        addTestCase("Thread test", \threadTest());
        addTestCase("Env vars test", \envVarsTest());
        addTestCase("Env var negative test", \envVarsNegativeTest());
        addTestCase("working dir test", \cwdTest());
        addTestCase("custom PATH test negative", \pathTestNegative());
        addTestCase("detach test", \detachTest());
        addTestCase("detach test negative", \detachTestNegative());
        addTestCase("wait timeout", \waitTimeoutTest());
        addTestCase("mem and checkPid test", \memoryAndCheckPidTest());
        addTestCase("terminate test", \terminateTest());

        # Return for compatibility with test harness that checks return value.
        set_return_value(main());
    }

    string prefix() {
        return m_prefix;
    }

    any getTestValue(string key) {
        string os = Qore::PlatformOS.upr();
        if (!m_test_paths.hasKey(os)) {
            throw "MISSING-TEST-SETUP", sprintf("There is no TEST_PATHS setup for OS: %s, known OSes: %n", os, m_test_paths.keys());
        }

        if (!m_test_paths.DEFAULT.hasKey(key) && !m_test_paths{os}.hasKey(key)) {
            throw "MISSING-TEST-SETUP", sprintf("There is no TEST_PATHS setup for OS: %s, test_name: %s", os, key);
        }

        return m_test_paths{os}{key} ?? m_test_paths.DEFAULT{key};
    }

    globalSetUp() {
    }

    globalTearDown() {
    }

    searchPathTest() {
        any s = Process::searchPath(getTestValue("searchPathTest_in"));
        assertRegex(getTestValue("searchPathTest_out"), s, sprintf("searchPath for %s", getTestValue("searchPathTest_in")));

        try {
            Process::searchPath("some-not-existing-exec");
            assertEq(0, 1, "some-not-existing-exec for searchPath");
        }
        catch (hash ex) {
            assertEq("PROCESS-SEARCH-PATH-ERROR", ex.err, "some-not-existing-exec for searchPath");
        }
    }

    absoluteTest() {
        string path = normalize_dir(get_script_dir() + DirSep + "test_true.q");
        Process proc(path);
        proc.wait();
        assertEq(0, proc.exitCode());

        # negative tests
        path = "abc" + DirSep + "test_true.q";
        assertThrows("PROCESS-SEARCH-PATH-ERROR", sub () { proc = new Process(path, ("path": ())); });
        path = "test_true.q";
        assertThrows("PROCESS-SEARCH-PATH-ERROR", sub () { proc = new Process(path); });
        path = DirSep + "test_true.q";
        assertThrows("PROCESS-CONSTRUCTOR-ERROR", sub () { proc = new Process(path, ("path": ())); });
    }

    constructorTest() {
        hash opts = (
                "path" : ( m_prefix, ),
                "env" : ( "FOO" : "bar" ) + ENV,
            );

        string exe = getTestValue("testTrue");
        softlist args = ( 1, );

        try {
            Process p1(exe);
            p1.wait();
            fail();
        }
        catch (hash ex) {
            assertEq("PROCESS-SEARCH-PATH-ERROR", ex.err, "it should not be found");
        }

        Process p2(exe, args, opts);
        p2.wait();
        assertEq(0, p2.exitCode(), "exit code p2");

        Process p3(exe, opts);
        p3.wait();
        assertEq(0, p3.exitCode(), "exit code p3");
    }

    simpleTest() {
        Process p(getTestValue("simpleTest_exe"), getTestValue("simpleTest_arg"));
        assertEq(True, p.id() > 0, "PID must be given");
        assertEq(True, p.valid(), "process must be valid");

        p.wait();
        assertEq(0, p.exitCode());
    }

    simpleTestNegative() {
        try {
            Process p("some-not-existing-exec");
            p.wait();
            fail();
        }
        catch (hash ex) {
            assertEq("PROCESS-SEARCH-PATH-ERROR", ex.err, "some-not-existing-exec for Process");
        }
    }

    executorsTest() {
        hash opts = (
                "path" : ( m_prefix, ),
                "on_success" : sub (hash e) {
                    if (m_options.verbose)
                        printf("    on_success attribute: %n\n", e);
                    assertEq("on_success", e.name, "name check");
                    assertEq(127, e.exit, "on_success exit code check");
                    assertEq(m_prefix + getTestValue("testTrue"), e.exe, "on_success exe check");
                    assertEq(0, e.error_code, "on_success error_code check");
                    assertEq(getTestValue("executorsTest_success"), e.error_message, "on_success error_message check");
                    assertEq("system", e.error_category, "on_success error_category check");
                },
                "on_setup" : sub (hash e) {
                    if (m_options.verbose)
                        printf("    on_setup attribute: %n\n", e);
                    assertEq("on_setup", e.name, "name check");
                },
                "on_error" : sub (hash e) {
                    if (m_options.verbose)
                        printf("    on_error attribute: %n\n", e);
                    assertEq("on_error", e.name, "name check");
                },
                "on_fork_error" : sub (hash e) {
                    if (m_options.verbose)
                        printf("    on_fork_error attribute: %n\n", e);
                    assertEq("on_fork_error", e.name, "name check");
                },
                "on_exec_setup" : sub (hash e) {
                    if (m_options.verbose)
                        printf("    on_exec_setup attribute: %n\n", e);
                    assertEq("on_exec_setup", e.name, "name check");
                },
                "on_exec_error" : sub (hash e) {
                    if (m_options.verbose)
                        printf("    on_exec_error attribute: %n\n", e);
                    assertEq("on_exec_error", e.name, "name check");
                },
            );

        Process p(getTestValue("testTrue"), opts);
        p.wait();
        assertEq(0, p.exitCode(), "expected 0 retval");
    }

    executorMethod(hash e) {
        if (m_options.verbose) printf("executorMethod: %n\n", e);
        assertEq("on_success", e.name, "name check");
        assertEq(127, e.exit, "on_success exit code check");
        assertEq(m_prefix + getTestValue("testTrue"), e.exe, "on_success exe check");
        assertEq(0, e.error_code, "on_success error_code check");
        assertEq(getTestValue("executorsTest_success"), e.error_message, "on_success error_message check");
        assertEq("system", e.error_category, "on_success error_category check");
    }

    static executorStaticMethod(hash e) {
        if (VERBOSE) printf("executorStaticMethod: %n\n", e);
        MAIN.assertEq("on_success", e.name, "name check");
        MAIN.assertEq(127, e.exit, "on_success exit code check");
        MAIN.assertEq(MAIN.prefix() + MAIN.getTestValue("testTrue"), e.exe, "on_success exe check");
        MAIN.assertEq(0, e.error_code, "on_success error_code check");
        MAIN.assertEq(MAIN.getTestValue("executorsTest_success"), e.error_message, "on_success error_message check");
        MAIN.assertEq("system", e.error_category, "on_success error_category check");
    }

    executorNoHash() {
        hash e = argv[0];
        if (m_options.verbose) printf("executorNoHash: %n\n", e);
        assertEq("on_success", e.name, "name check");
        assertEq(127, e.exit, "on_success exit code check");
        assertEq(m_prefix + getTestValue("testTrue"), e.exe, "on_success exe check");
        assertEq(0, e.error_code, "on_success error_code check");
        assertEq(getTestValue("executorsTest_success"), e.error_message, "on_success error_message check");
        assertEq("system", e.error_category, "on_success error_category check");
    }

    executorsRefsTest() {
        list opts = (
            ( "on_success" : \executor_func() ), # function ref
            ( "on_success" : \self.executorMethod() ), # method ref
            ( "on_success" : \Main::executorStaticMethod() ), # static method ref
            ( "on_success" : \self.executorNoHash() ), # no arguments
        );

        ListIterator it(opts);
        while (it.next()) {
            Process p(getTestValue("testTrue"), it.getValue() + ("path" : (m_prefix,)));
            p.wait();
            assertEq(0, p.exitCode(), "expected 0 retval");
        }
    }

    executorsNegativeTest() {
        try {
            hash opts = (
                    "path" : ( m_prefix, ),
                    "on_success" : 1,
                );
            Process p(getTestValue("testTrue"), opts);
        }
        catch (hash ex) {
            assertEq("PROCESS-OPTIONS-ERROR", ex.err, "on_success using integer: err");
            assertEq("executor 'on_success' required code as value, got: 'integer'(1)",
                     ex.desc,
                     "on_success using integer: desc"
                    );
        }

        try {
            hash opts = (
                    "path" : (m_prefix, ),
                    "on_success" : sub (int i) {},
                );
            Process p(getTestValue("testTrue"), opts);
        }
        catch (hash ex) {
            assertEq("RUNTIME-TYPE-ERROR", ex.err, "on_success using code with no hash as arg: err");
            assertEq("parameter 1 ('i') expects type 'int', but got type 'hash' instead",
                     ex.desc,
                     "on_success using code with no hash as arg: desc"
                    );
        }
    }

    ioTest() {
        string str = "text to write\n";
        hash opts = (
                "path" : ( m_prefix, ),
            );
        Process p("test_io.q", opts);

        assertEq(NOTHING, p.readStdout(1000));
        assertEq(NOTHING, p.readStderr(1000));
        
        p.write(str);

        sleep(1s); # sleep to make sure that there is some stdout data ready

        string b1 = p.readStdout(1);
        assertEq("t", b1, "byte 1 stdout read test");
        string b2 = p.readStdout(2);
        assertEq("ex", b2, "byte 2 stdout read test");

        b2 = p.readStdout(1000);
        assertEq(str.substr(3), b2);

        b1 = p.readStderr(1);
        assertEq("1", b1, "byte 1 stderr read test");
        b2 = p.readStderr(2);
        assertEq("23", b2, "byte 2 stderr read test");

        for (int i = 0; i < 10; i++) {
            assertEq(NOTHING, p.readStdout(1000));
            assertEq(NOTHING, p.readStderr(1000));
        }

        string testStr;
        for (int i = 0; i < 10; i++) {
            testStr += string(rand());
            testStr += testStr;
        }

        p.write(testStr + "\n");

        b1 = "";
        while (b1.size() < testStr.size()) {
            b1 += p.readStderr(1000);
        }
        assertEq(testStr, b1);

        b1 = "";
        while (b1.size() < testStr.size()) {
            b1 += p.readStdout(1000);
        }
        assertEq(testStr, b1);

        int retCode = (rand().abs() % 256);
        p.write(string(retCode) + "\n");

        p.wait();
        assertEq(False, p.running());
        assertEq(retCode, p.exitCode());
    }

    threadTest() {
        Process p("tee");
        assertEq(True, p.id() > 0, "PID must be given");
        assertEq(True, p.valid(), "process must be valid");
        assertEq(True, p.running(), "process must be running");

        background run_bg(p, self);
        #p.write("foobar");
        sleep(1s);
        p.terminate();
    }

    envVarsTest() {
        hash opts_p = ( "path" : ( m_prefix, ),
                        "env" : ENV,
                      );

        {
            hash opts = opts_p;
            opts.env += ( "FOO" : "bar" );
            Process p("test_env.q", ("FOO", "bar"), opts);
            p.wait();
            assertEq(0, p.exitCode(), "env var retval for passed env");
        }

        # negative test
        {
            hash opts = opts_p;
            Process p("test_env.q", ("FOO", "bar"), opts);
            p.wait();
            assertEq(3, p.exitCode(), "env var retval for NOT passed env");
        }
    }

    envVarsNegativeTest() {
        hash opts = (
                "path" : (m_prefix,),
                "env" : 1, # let's try something else than hash for envs
            );

        try {
            Process p(getTestValue("testTrue"), opts);
            p.wait();
            assertEq(True, False, "envVarsNegativeTest cannot go here");
        }
        catch (hash ex) {
            assertEq("PROCESS-OPTIONS-ERROR", ex.err, "envVarsNegativeTest negative: err");
            assertEq("Environment variables option must be a hash, got: 'integer'(1)",
                     ex.desc,
                     "envVarsNegativeTest negative: desc"
                    );
        }
    }

    cwdTest() {
        hash opts = (
                "cwd" : Util::tmp_location(),
                "path" : ( m_prefix, ),
            );
        Process p("test_cwd.q", opts);
        sleep(1s); # wait so there is surely stdout output

        *string e = p.readStdout(1000);
        assertEq(opts.cwd, e, "cwd value read from stdout");

        p.wait();
        assertEq(0, p.exitCode(), "process exit code");
    }

    pathTestNegative() {
        hash opts = (
                "path" : ( "/", ),
            );
        try {
            Process p(getTestValue("testTrue"), opts);
            p.wait();
            fail();
        }
        catch (hash ex) {
            assertEq("PROCESS-SEARCH-PATH-ERROR", ex.err, "ex.err check");
            assertEq("Command 'test_true.q' cannot be found in PATH", ex.desc, "ex.desc check");
        }
    }

    detachTest() {
        int pid;
        {
            Process p(getTestValue("testSleep"), 5, ("path" : (m_prefix,)));
            pid = p.id();
            p.detach();
            assertEq(True, p.running(), "Detached process is running");
        }

        {
            Process p(pid);
            assertEq(True, p.running(), "Detached process is still running");
            p.terminate();
            assertEq(False, p.running(), "Detached process is not running");
            p.wait();
            assertEq(False, p.running(), "Detached process is not running");
        }
    }

    detachTestNegative() {
        int pid;
        {
            Process p(getTestValue("testSleep"), 5, ("path" : (m_prefix,)));
            pid = p.id();
        }

        {
            Process p(pid);
            assertEq(False, p.running(), "Detached process is not running");
        }
    }

    waitTimeoutTest() {
        Process p(getTestValue("testSleep"), 3, ("path" : (m_prefix,)));
        assertFalse(p.wait(1s));
        assertTrue(p.wait(5s));
        assertTrue(p.wait());
        assertEq(0, p.exitCode(), "process exit code");
    }

    memoryAndCheckPidTest() {
        if (HAVE_PROCESS_GETMEMORYINFO) {
            hash<auto> h = Process::getMemorySummaryInfo();
            assertGt(0, h.vsz);
            assertGt(0, h.rss);
            assertGt(0, h.priv);
            assertEq("hash<MemorySummaryInfo>", h.fullType());
            assertThrows("PROCESS-GETMEMORYINFO-ERROR", \Process::getMemorySummaryInfo(), -10);
        }
        else {
            assertThrows("PROCESS-GETMEMORYINFO-UNSUPPORTED-ERROR", \Process::getMemorySummaryInfo(), -10);
        }

        if (HAVE_PROCESS_CHECKPID) {
            assertTrue(Process::checkPid(getpid()));
        }
        else {
            assertThrows("PROCESS-CHECKPID-UNSUPPORTED-ERROR", \Process::checkPid(), -10);
        }
    }

    terminateTest() {
        Process p("tee");
        assertTrue(p.running());
        int pid = p.id();
        Process::terminate(pid);
        # we do not have to call Process::waitForTermination() here because we are terminating a child process
        # and terminate calls waitpid() on Unix platforms
        assertFalse(p.running());
        if (HAVE_PROCESS_CHECKPID) {
            assertFalse(Process::checkPid(pid));
        }

        # negative test for Process::terminate() with an invalid PID
        assertThrows("PROCESS-INVALID-PID", \Process::terminate(), 9999999);

        if (HAVE_PROCESS_WAITFORTERMINATION) {
            # negative test for Process::waitForTermination() with an invalid PID
            assertNothing(Process::waitForTermination(9999999));
        }
        else {
            assertThrows("PROCESS-WAITFORTERMINATION-UNSUPPORTED-ERROR", \Process::waitForTermination(), -10);
        }
    }
}

sub run_bg(Process p, Main m) {
    m.assertEq(True, p.id() > 0, "PID must be given");
    m.assertEq(True, p.valid(), "process must be valid");
    m.assertEq(True, p.running(), "process must be running");

    try {
        p.wait();
    }
    catch (hash ex) {
        m.assertEq("PROCESS-WAIT-ERROR", ex.err, "process is killed from main thread - err");
        m.assertEq(True, ex.desc.regex("No child processes"), ex.desc, "process is killed from main thread - desc");
    }
}

sub executor_func(hash e) {
    if (VERBOSE) printf("executor_func: %n\n", e);
    MAIN.assertEq("on_success", e.name, "name check");
    MAIN.assertEq(127, e.exit, "on_success exit code check");
    MAIN.assertEq(MAIN.prefix() + MAIN.getTestValue("testTrue"), e.exe, "on_success exe check");
    MAIN.assertEq(0, e.error_code, "on_success error_code check");
    MAIN.assertEq(MAIN.getTestValue("executorsTest_success"), e.error_message, "on_success error_message check");
    MAIN.assertEq("system", e.error_category, "on_success error_category check");
}
